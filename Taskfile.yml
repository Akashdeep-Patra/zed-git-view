version: "3"

vars:
  BINARY_NAME: zgv
  BUILD_DIR: bin
  MAIN_PKG: ./cmd
  VERSION:
    sh: git describe --tags --always --dirty 2>/dev/null || echo "dev"
  COMMIT:
    sh: git rev-parse --short HEAD 2>/dev/null || echo "none"
  DATE:
    sh: date -u '+%Y-%m-%dT%H:%M:%SZ'
  LDFLAGS: -s -w -X main.version={{.VERSION}} -X main.commit={{.COMMIT}} -X main.date={{.DATE}}

tasks:
  default:
    desc: Show available tasks
    cmds:
      - task --list-all

  build:
    desc: Build the binary with version metadata
    cmds:
      - go build -ldflags="{{.LDFLAGS}}" -o {{.BUILD_DIR}}/{{.BINARY_NAME}} {{.MAIN_PKG}}
    sources:
      - "**/*.go"
      - go.mod
      - go.sum
    generates:
      - "{{.BUILD_DIR}}/{{.BINARY_NAME}}"

  run:
    desc: Build and run
    deps: [build]
    cmds:
      - ./{{.BUILD_DIR}}/{{.BINARY_NAME}} {{.CLI_ARGS}}

  dev:
    desc: Run with hot-reload (rebuilds and restarts on .go file changes)
    cmds:
      - watchexec -r -e go -- go run {{.MAIN_PKG}}
    preconditions:
      - sh: command -v watchexec
        msg: "watchexec is required: brew install watchexec"

  test:
    desc: Run tests with race detector
    cmds:
      - go test -race -coverprofile=coverage.txt ./...

  test:short:
    desc: Run short tests only
    cmds:
      - go test -short ./...

  coverage:
    desc: Generate and open HTML coverage report
    deps: [test]
    cmds:
      - go tool cover -html=coverage.txt -o coverage.html
      - open coverage.html

  lint:
    desc: Run golangci-lint
    cmds:
      - golangci-lint run ./...

  lint:fix:
    desc: Run golangci-lint with auto-fix
    cmds:
      - golangci-lint run --fix ./...

  fmt:
    desc: Format code with gofumpt
    cmds:
      - gofumpt -w .

  vet:
    desc: Run go vet
    cmds:
      - go vet ./...

  tidy:
    desc: Tidy go modules
    cmds:
      - go mod tidy

  clean:
    desc: Remove build artifacts
    cmds:
      - rm -rf {{.BUILD_DIR}} dist coverage.txt coverage.html

  install:
    desc: Install binary to GOPATH/bin with version metadata
    cmds:
      - go install -ldflags="{{.LDFLAGS}}" {{.MAIN_PKG}}

  snapshot:
    desc: Build a snapshot release locally (no publish)
    cmds:
      - goreleaser build --snapshot --clean

  release:dry:
    desc: Dry-run a full release (no publish)
    cmds:
      - goreleaser release --snapshot --clean

  check:
    desc: Run all checks (fmt, vet, lint, test)
    cmds:
      - task: fmt
      - task: vet
      - task: lint
      - task: test

  version:
    desc: Print the current version
    cmds:
      - echo "{{.VERSION}} ({{.COMMIT}})"

  ci:local:
    desc: Run CI workflow locally using act (requires Docker)
    cmds:
      - act push -j vet -W .github/workflows/ci.yml
      - act push -j test -W .github/workflows/ci.yml
      - act push -j build --matrix goos:linux --matrix goarch:amd64 -W .github/workflows/ci.yml
    preconditions:
      - sh: command -v act
        msg: "act is required: brew install act"
      - sh: docker info > /dev/null 2>&1
        msg: "Docker must be running"

  ci:local:vet:
    desc: Run just the CI vet job locally
    cmds:
      - act push -j vet -W .github/workflows/ci.yml

  ci:local:test:
    desc: Run just the CI test job locally
    cmds:
      - act push -j test -W .github/workflows/ci.yml

  ci:local:build:
    desc: Run just the CI build job locally (linux/amd64)
    cmds:
      - act push -j build --matrix goos:linux --matrix goarch:amd64 -W .github/workflows/ci.yml

  tag:
    desc: "Create and push a release tag: task tag -- v0.2.0"
    cmds:
      - git tag -a {{.CLI_ARGS}} -m "Release {{.CLI_ARGS}}"
      - git push origin {{.CLI_ARGS}}
    preconditions:
      - sh: test -n "{{.CLI_ARGS}}"
        msg: "Usage: task tag -- v0.2.0"

  release:
    desc: "Seamless release: task release -- major|minor|patch"
    cmds:
      - task: check
      - |
        LEVEL="{{.CLI_ARGS}}"
        LAST_TAG="$(git tag --list 'v*' --sort=-version:refname | head -n1)"
        if [ -z "${LAST_TAG}" ]; then
          LAST_TAG="v0.0.0"
        fi

        BASE="${LAST_TAG#v}"
        IFS=. read -r MAJOR MINOR PATCH <<EOF
        ${BASE}
        EOF

        MAJOR="${MAJOR:-0}"
        MINOR="${MINOR:-0}"
        PATCH="${PATCH:-0}"

        case "${LEVEL}" in
          major)
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
            ;;
          minor)
            MINOR=$((MINOR + 1))
            PATCH=0
            ;;
          patch)
            PATCH=$((PATCH + 1))
            ;;
        esac

        NEXT_TAG="v${MAJOR}.${MINOR}.${PATCH}"
        if git rev-parse -q --verify "refs/tags/${NEXT_TAG}" >/dev/null 2>&1; then
          echo "Tag already exists locally: ${NEXT_TAG}"
          exit 1
        fi

        echo "Releasing ${NEXT_TAG} (from ${LAST_TAG}, level=${LEVEL})"
        git tag -a "${NEXT_TAG}" -m "Release ${NEXT_TAG}"
        git push origin "${NEXT_TAG}"
    preconditions:
      - sh: test -n "{{.CLI_ARGS}}"
        msg: "Usage: task release -- major|minor|patch"
      - sh: 'printf "%s" "{{.CLI_ARGS}}" | rg -q "^(major|minor|patch)$"'
        msg: "Release level must be one of: major, minor, patch"
      - sh: '[ -z "$(git status --porcelain)" ]'
        msg: "Working tree must be clean before release"
